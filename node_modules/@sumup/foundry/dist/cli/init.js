"use strict";
/**
 * Copyright 2019, SumUp Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePath = exports.init = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const inquirer_1 = __importDefault(require("inquirer"));
const listr_1 = __importDefault(require("listr"));
const listr_inquirer_1 = __importDefault(require("listr-inquirer"));
const fp_1 = require("lodash/fp");
const chalk_1 = __importDefault(require("chalk"));
const is_ci_1 = __importDefault(require("is-ci"));
const read_pkg_up_1 = __importDefault(require("read-pkg-up"));
const shared_1 = require("../types/shared");
const logger = __importStar(require("../lib/logger"));
const files_1 = require("../lib/files");
const presets_1 = require("../presets");
const configs_1 = require("../configs");
const defaults_1 = require("./defaults");
async function init({ $0, _, ...args }) {
    let options;
    const selectedPresets = [shared_1.Preset.LINT];
    if (!is_ci_1.default) {
        const prompts = {
            [shared_1.Prompt.OPEN_SOURCE]: {
                type: 'confirm',
                name: 'openSource',
                message: 'Do you intend to open-source this project?',
                default: defaults_1.DEFAULT_OPTIONS.openSource,
                when: () => typeof args.openSource === 'undefined',
            },
        };
        const additionalPrompts = getPromptsForPresets(selectedPresets, prompts);
        const additionalAnswers = await inquirer_1.default.prompt(additionalPrompts);
        options = { ...args, ...additionalAnswers };
    }
    else {
        logger.empty();
        logger.info('Detected CI environment, falling back to default options.');
        options = { ...defaults_1.DEFAULT_OPTIONS, ...args };
    }
    const selectedTools = getToolsForPresets(selectedPresets);
    const files = getFilesForTools(options, selectedTools);
    const scripts = getScriptsForTools(options, selectedTools);
    logger.empty();
    const tasks = new listr_1.default([
        {
            title: 'Writing config files',
            task: () => new listr_1.default(files.map((file) => ({
                title: `Write "${file.name}"`,
                task: (ctx, task) => (0, files_1.writeFile)(options.configDir, file.name, file.content, options.overwrite).catch(() => {
                    logger.debug(`File "${file.name}" already exists`);
                    if (is_ci_1.default) {
                        logger.debug('In a CI environment, skipping...');
                        task.skip('Skipped');
                        return undefined;
                    }
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return
                    return (0, listr_inquirer_1.default)([
                        {
                            type: 'confirm',
                            name: 'overwrite',
                            // eslint-disable-next-line max-len
                            message: `"${file.name}" already exists. Would you like to replace it?`,
                            default: false,
                        },
                    ], ({ overwrite }) => {
                        logger.debug(`Overwrite file: ${overwrite.toString()}`);
                        if (!overwrite) {
                            task.skip('Skipped');
                            return undefined;
                        }
                        return (0, files_1.writeFile)(options.configDir, file.name, file.content, true);
                    });
                }),
            }))),
        },
        {
            title: 'Updating package.json',
            // eslint-disable-next-line @typescript-eslint/require-await
            task: async () => {
                return new listr_1.default([
                    {
                        title: 'Read package.json',
                        task: async (ctx) => {
                            const pkg = await (0, read_pkg_up_1.default)();
                            if (!pkg) {
                                throw new Error('Unable to find a "package.json" file.');
                            }
                            ctx.packagePath = pkg.path;
                            ctx.packageJson = pkg.packageJson;
                        },
                    },
                    {
                        title: 'Add license field',
                        enabled: () => options.openSource === true,
                        task: (ctx) => {
                            ctx.packageJson.license = 'Apache-2.0';
                        },
                    },
                    ...scripts.map(({ name, command }) => ({
                        title: `Add "${name}" script`,
                        task: (ctx, task) => {
                            try {
                                (0, files_1.addPackageScript)(ctx.packageJson, name, command, options.overwrite);
                                return undefined;
                            }
                            catch (error) {
                                logger.debug(`Script "${name}" already exists`);
                                if (is_ci_1.default) {
                                    logger.debug('In a CI environment, skipping...');
                                    task.skip('Skipped');
                                    return undefined;
                                }
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return
                                return (0, listr_inquirer_1.default)([
                                    {
                                        type: 'confirm',
                                        name: 'overwriteScript',
                                        // eslint-disable-next-line max-len
                                        message: `"${name}" already exists. Would you like to replace it?`,
                                        default: false,
                                    },
                                ], ({ overwriteScript }) => {
                                    logger.debug(`Overwrite script: ${overwriteScript.toString()}`);
                                    if (!overwriteScript) {
                                        task.skip('Skipped');
                                        return;
                                    }
                                    (0, files_1.addPackageScript)(ctx.packageJson, name, command, true);
                                });
                            }
                        },
                    })),
                    {
                        title: 'Save package.json',
                        task: (ctx) => (0, files_1.savePackageJson)(ctx.packagePath, ctx.packageJson),
                    },
                ]);
            },
        },
    ]);
    tasks
        .run()
        .then(() => {
        logger.empty();
        logger.info('Added the following scripts to "package.json":');
        logger.empty();
        scripts.forEach(({ name, description }) => {
            logger.log(`  ${chalk_1.default.bold(`"${name}"`)}: ${description}`);
        });
    })
        .catch((error) => {
        logger.error(error);
        process.exit(1);
    });
}
exports.init = init;
function getPromptsForPresets(selectedPresets, prompts) {
    return (0, fp_1.flow)((0, fp_1.map)((preset) => presets_1.presets[preset].prompts || []), fp_1.flatten, fp_1.uniq, (0, fp_1.map)((prompt) => prompts[prompt]))(selectedPresets);
}
function getToolsForPresets(selectedPresets) {
    return (0, fp_1.flow)((0, fp_1.map)((preset) => presets_1.presets[preset].tools), fp_1.flatten, fp_1.uniq, (0, fp_1.map)((tool) => configs_1.tools[tool]))(selectedPresets);
}
function getFilesForTools(options, selectedTools) {
    return selectedTools.reduce((allFiles, tool) => {
        if (tool.files) {
            const filesForTool = tool.files(options);
            allFiles.push(...filesForTool);
        }
        return allFiles;
    }, []);
}
function getScriptsForTools(options, selectedTools) {
    return selectedTools.reduce((allScripts, tool) => {
        if (tool.scripts) {
            const scriptsForTool = tool.scripts(options);
            return [...allScripts, ...scriptsForTool];
        }
        return allScripts;
    }, []);
}
function validatePath(path) {
    if (!path) {
        return false;
    }
    const resolvedPath = (0, path_1.resolve)(path);
    if (!(0, fs_1.existsSync)(resolvedPath)) {
        return `The path "${resolvedPath}" doesn't exist. Please try another one.`;
    }
    return true;
}
exports.validatePath = validatePath;
